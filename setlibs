#! /bin/bash
#
# michael cousins
# http://www.github.com/mcous/kicad-lib
# this script file released into the public domain

# setlibs - adds or replaces the libraries of a kicad project with these libraries
#
#   usage: setlibs [flags] /path/to/project.pro [/paths/to/more/projects.pro]
#
#   flags: 
# TODO:-a, --append      = append libraries rather than replacing them
# TODO:-b, --before      = if appending, append new libraries before old ones (does not apply to power library)
#     -c, --components  = only do component files
#     -f, --footprints  = only do footprint files
#     -h, --help        = display this little summary
# TODO:-v, --version     = display version number of the library

# constants
# kicad project file options
readonly HEAD_MATCH="[[]"
readonly C_DIR_HEAD_MATCH="eeschema"
readonly C_DIR_MATCH="LibDir"
readonly C_LIB_HEAD_MATCH="eeschema/libraries"
readonly C_LIB_MATCH="LibName[0-9]"
readonly F_DIR_HEAD_MATCH="pcbnew/libraries"
readonly F_DIR_MATCH="LibDir"
readonly F_LIB_HEAD_MATCH="pcbnew/libraries"
readonly F_LIB_MATCH="LibName[0-9]"
# valid parameters
readonly SHORT_FLAGS=("a" "p" "c" "f" "h")
readonly LONG_FLAGS=("append" "prepend" "components" "footprints" "help")

# script flags
REPLACE=true
APPEND=false
PREPEND=false
COMPONENTS=true
FOOTPRINTS=true

# current program options
OPTS=()
PRJ=()

# library lists
COMPS=()
FOOTS=()

# functions
function go () {
  # parse input
  checkinput $@
  # check options are good
  checkopts
  # run with it
  run
}

# get the absolute location of the script so I can get directory paths
# solution from http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
function getScriptLoc () {
  SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  #echo "script is running from: $SCRIPT_DIR"
}

# help function
function help () {
  echo ""
  echo "setlibs - adds or replaces the libraries of a kicad project with the libraries from github.com/mcous/kicad-lib"
  echo "  default behavior: removes all component and footprint libraries in project file and replaces them with new libraries"
  echo "  usage: ./setlibs [flags] [paths to .pro files]"
  echo "  examples:"
  echo "    replace all libraries in two projects:"
  echo "      ./setlibs path/to/project1.pro path/to/project2.pro"
  echo "    append only the footprint libraries to a project"
  echo "      ./setlibs --append --footprints path/to/project.pro"
  echo "  flags: "
  echo "    -a, --append      = append new libraries rather than replacing them"
  echo "    -p, --prepend     = prepend new libraries (will keep power component library at top)" # reconsider this
  echo "    -c, --components  = only do component files"
  echo "    -f, --footprints  = only do footprint files"
  echo "    -h, --help        = display this little summary"
  exit 0
}

# check the input to make sure that any options are correct and the file(s) exists
function checkinput () {
  local inv=false

  local shortMatch="^-[a-z]+$"
  local chainedShortMatch="^-[a-z]+$"
  local longMatch="^-{2}[a-z][a-z]+$"
  local proMatch="[a-z]+\.pro$"

  for ARG in "$@"
  do
    local valid=false
    # check if its a short flag
    if [[ $ARG =~ $shortMatch ]]
      then
      # break up the options if needed
      local len=${#ARG}
      while [ $len -gt 1 ]
      do
        # check if it's a valid short flag
        local flag=${ARG:($len-1):1}
        for VALIDOPT in "${SHORT_FLAGS[@]}"
        do
          if [ "$flag" = "$VALIDOPT" ]
            then
            valid=true
            OPTS+=("$VALIDOPT")
            break
          fi
        done
        let "len -= 1"
      done
      # if invalid input
      if ! $valid
        then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check of its a long flag
    elif [[ $ARG =~ $longMatch ]]
      then
      # check if it's a valid long flag
      local flag=${ARG:2}
      for VALIDOPT in "${LONG_FLAGS[@]}"
      do
        if [ "$flag" = "$VALIDOPT" ]
          then
          valid=true
          OPTS+=("$VALIDOPT")
          break
        fi
      done
      if ! $valid
        then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check if its a project file
    elif [[ $ARG =~ $proMatch ]]
      then
      # check if file exists
      if [ -e $ARG ]
        then
        PRJ+=("$ARG")
        valid=true
      else
        echo "ERROR: $ARG does not exist"
      fi

    # else input is invalid
    else
      echo "ERROR: $ARG is not valid input"
    fi

    if ! $valid
      then
      inv=true
    fi
  done

  # if there were errors
  if $inv
    then
    help
  fi
}

# check for conflicting options and set script flags
function checkopts () {
  # set the flags
  for OP in ${OPTS[@]}
  do
    if [ "${OP:0:1}" = "h" ]
      then
      help
    elif [ "${OP:0:1}" = "a" ]
      then
      APPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "p" ]
      then
      PREPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "c" ]
      then
      FOOTPRINTS=false
    elif [ "${OP:0:1}" = "f" ]
      then
      COMPONENTS=false
    fi
  done

  local inv=false
  # make sure there are no conflicting flags
  if $APPEND && $PREPEND
    then
    echo "ERROR: append and prepend options are mutually exclusive"
    inv=true
  fi
  if ! $FOOTPRINTS && ! $COMPONENTS
    then
    echo "ERROR: components-only and footprints-only options are mutually exclusive"
    inv=true
  fi
  # also make sure there are project files
  if [ ! "${PRJ[0]}" ]
    then
    echo "ERROR: no kicad project file entered"
    inv=true
  fi

  if $inv
    then
    help
  fi
}

function buildLists () {
  if $COMPONENTS
    then
    local dir="$SCRIPT_DIR/components/*.lib"
    for C in $dir
    do
      local f=`basename $C`
      COMPS+=(${f%%.lib})
      #echo "hey look: $f"
    done
    #echo "component libraries: ${COMPS[@]}"
  fi

  if $FOOTPRINTS
    then
    local dir="$SCRIPT_DIR/footprints/*.mod"
    for F in $dir
    do
      local f=`basename $F`
      FOOTS+=(${f%%.mod})
      #echo "hey look: $f"
    done
    #echo "footprint libraries: ${FOOTS[@]}"
  fi
}

# get the heading locations in the pro files for seds
function getBoundries () {
  # hey look grep works to get all the headings. oops.
  local headings=`grep -n "$HEAD_MATCH" $P`
  local inv=false
  
  if $COMPONENTS
    then
    # get the line number bounds of the component libraries
    C_LIB_BOUND=( `echo "$headings" | sed -n "\:$C_LIB_HEAD_MATCH: { s/:.*//p; n; s/:.*//p; }"` )
    if [ ! ${C_LIB_BOUND[0]} ]
      then
      echo -e "ERROR: invalid kicad project file: [$C_LIB_HEAD_MATCH] not found"
      inv=true
    fi
    if [ ! ${C_LIB_BOUND[1]} ]
      then
      C_LIB_BOUND[1]='$'
    fi
    #echo "component library bounds: ${C_LIB_BOUND[@]}"
    # do the same for the directory
    C_DIR_BOUND=( `echo "$headings" | sed -n "\:$C_DIR_HEAD_MATCH: { s/:.*//p; n; s/:.*//p; }"` )
    if [ ! ${C_DIR_BOUND[0]} ]
      then
      echo -e "ERROR: invalid kicad project file: [$C_DIR_HEAD_MATCH] not found"
      inv=true
    fi
    if [ ! ${C_DIR_BOUND[1]} ]
      then
      C_DIR_BOUND[1]='$'
    fi
    #echo "component directory bounds: ${C_DIR_BOUND[@]}"
  fi

  if $FOOTPRINTS
    then
    # get the line number bounds of the footprint libraries
    F_LIB_BOUND=( `echo "$headings" | sed -n "\:$F_LIB_HEAD_MATCH: { s/:.*//p; n; s/:.*//p; }"` )
    if [ ! ${F_LIB_BOUND[0]} ]
      then
      echo -e "ERROR: invalid kicad project file: [$F_LIB_HEAD_MATCH] not found"
      inv=true
    fi
    if [ ! ${F_LIB_BOUND[1]} ]
      then
      F_LIB_BOUND[1]='$'
    fi
    #echo "footprint library bounds: ${F_LIB_BOUND[@]}"
    # do the same for the directory
    F_DIR_BOUND=( `echo "$headings" | sed -n "\:$F_DIR_HEAD_MATCH: { s/:.*//p; n; s/:.*//p; }"` )
    if [ ! ${F_DIR_BOUND[0]} ]
      then
      echo -e "ERROR: invalid kicad project file: [$F_DIR_HEAD_MATCH] not found"
      inv=true
    fi
    if [ ! ${F_DIR_BOUND[1]} ]
      then
      F_DIR_BOUND[1]='$'
    fi
    #echo "footprint directory bounds: ${F_DIR_BOUND[@]}"
  fi

  if $inv
    then
    help
  fi
  # find the end of the section
  # search for the library line in that range
  # if append or prepend, append new dir to the end
  # if replace, straight up replace that shit
  # if no lib line found, add the line
}

# fix the directory lines in the pro file
function fixDirs () {
  if $COMPONENTS
    then
    local compdir="$SCRIPT_DIR/components"
    echo "component directory: $compdir"
    if $REPLACE
      then
      echo "replacing component directory"
      sed "${C_DIR_BOUND[0]},${C_DIR_BOUND[1]} s:LibDir=.*:LibDir=$compdir:" <$P >$P.temp
      mv $P.temp $P
    else
      echo "appending component directory"
      sed -e "${C_DIR_BOUND[0]},${C_DIR_BOUND[1]} s:\(LibDir=..*\):\1;$compdir:" -e t -e "${C_DIR_BOUND[0]},${C_DIR_BOUND[1]} s:LibDir=.*:LibDir=$compdir:" <$P >$P.temp
      mv $P.temp $P
    fi
  fi

  if $FOOTPRINTS
    then
    local footdir="$SCRIPT_DIR/footprints"
    echo "footprint directory: $footdir"
    if $REPLACE
      then
      echo "replacing footprint directory"
      sed "${F_DIR_BOUND[0]},${F_DIR_BOUND[1]} s:LibDir=.*:LibDir=$footdir:" <$P >$P.temp
      mv $P.temp $P
    else
      echo "appending footprint directory"
      sed -e "${F_DIR_BOUND[0]},${F_DIR_BOUND[1]} s:\(LibDir=..*\):\1;$footdir:" -e t -e "${F_DIR_BOUND[0]},${F_DIR_BOUND[1]} s:LibDir=.*:LibDir=$compdir:" <$P >$P.temp
      mv $P.temp $P
    fi
  fi
}

# fix the library lines in the pro file
function fixLibs () {
  echo "fixing libraries"
  if $COMPONENTS
    then
    echo "fixing component libraries"
    local libStart=1
    local insertAfter="$C_LIB_HEAD_MATCH"
    if $REPLACE
      then
      echo "deleting old libraries"
      sed -e "${C_LIB_BOUND[0]},${C_LIB_BOUND[1]} s/$C_LIB_MATCH.*//" -e '/^$/ d' <$P >$P.temp
      mv $P.temp $P
    else
      # gonna need library numbering
      #echo "last lib: "
      local libs=( `sed -n "${C_LIB_BOUND[0]},${C_LIB_BOUND[1]} s:$C_LIB_MATCH.*:&:p " <$P` )
      libStart=`echo "${libs[${#libs[@]} - 1]}" | grep -o [0-9][0-9]*`
      let libStart++
      echo "libstart: $libStart"
    fi
  fi
}

# do the magic
function run {
  # get the directory of the script for later
  getScriptLoc
 
  #echo "running on ${#PRJ[*]} projects:"
  #for P in "${PRJ[@]}"
  #do
  #  echo "$P"
  #done
  #echo "with these options:"
  #echo "replace libraries: $REPLACE"
  #echo "append libraries: $APPEND"
  #echo "prepend libraries: $PREPEND"
  #echo "use components: $COMPONENTS"
  #echo "use footprints: $FOOTPRINTS"

  # do this for every project
  for P in "${PRJ[@]}"
  do
    echo "taking care of $P"
    # back that shit up
    cp -f "$P" "$P".old

    # get necessary section boundries
    getBoundries
    # fix the diretories
    fixDirs
    # build the lists of libraries
    buildLists

      # edit the libraries
        # find the beginning of the section
        # find the end of the section
        # in the resulting range:
          # if append or prepend, get your library numbers figured out
            # new libraries will need numbering, old ones could need to be fixed
          # if replace, my life is easier
          # change lines until either list runs out
            # if new list, delete the remaining lines in the old list
            # elif the old list, insert remaining lines from the new list
        # output fixed project

    # finally, fix the libraries
    fixLibs

  done
}

# start the script
go $@
