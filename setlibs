#! /bin/bash
#
# michael cousins
# http://www.github.com/mcous/kicad-lib
# this script file released into the public domain

# setlibs - adds or replaces the libraries of a kicad project with these libraries
#
#   usage: setlibs [flags] /path/to/project.pro [/paths/to/more/projects.pro]
#
#   flags: 
# TODO:-a, --append      = append libraries rather than replacing them
# TODO:-b, --before      = if appending, append new libraries before old ones (does not apply to power library)
#     -c, --components  = only do component files
#     -f, --footprints  = only do footprint files
#     -h, --help        = display this little summary
# TODO:-v, --version     = display version number of the library

# constants
# kicad project file options
readonly HEADER_FORMAT="^\[[A-Za-z]+\]$"
readonly COMP_DIR_HEADING_MATCH="eeschema"
readonly COMP_DIR_MATCH="LibDir"
readonly COMP_LIB_HEADING_MATCH="eeschema/libraries"
readonly COMP_LIB_MATCH="LibName[0-9]"
readonly FOOT_DIR_HEADING_MATCH="pcbnew/libraries"
readonly FOOT_DIR_MATCH="LibDir"
readonly FOOT_LIB_HEADING_MATCH="pcbnew/libraries"
readonly FOOT_LIB_MATCH="LibName[0-9]"
# valid parameters
readonly SHORT_FLAGS=("a" "p" "c" "f" "h")
readonly LONG_FLAGS=("append" "prepend" "components" "footprints" "help")

# script flags
REPLACE=true
APPEND=false
PREPEND=false
COMPONENTS=true
FOOTPRINTS=true

# current program options
OPTS=()
PRJ=()

# library lists
COMPS=()
FOOTS=()

# functions
function go () {
  # parse input
  checkinput $@
  # check options are good
  checkopts
  # run with it
  run
}

# help function
function help () {
  echo ""
  echo "setlibs - adds or replaces the libraries of a kicad project with the libraries from github.com/mcous/kicad-lib"
  echo "  default behavior: removes all component and footprint libraries in project file and replaces them with new libraries"
  echo "  usage: ./setlibs [flags] [paths to .pro files]"
  echo "  examples:"
  echo "    replace all libraries in two projects:"
  echo "      ./setlibs path/to/project1.pro path/to/project2.pro"
  echo "    append only the footprint libraries to a project"
  echo "      ./setlibs --append --footprints path/to/project.pro"
  echo "  flags: "
  echo "    -a, --append      = append new libraries rather than replacing them"
  echo "    -p, --prepend     = prepend new libraries (will keep power component library at top)" # reconsider this
  echo "    -c, --components  = only do component files"
  echo "    -f, --footprints  = only do footprint files"
  echo "    -h, --help        = display this little summary"
  exit 0
}

# check the input to make sure that any options are correct and the file(s) exists
function checkinput () {
  local inv=false

  local shortMatch="^-[a-z]+$"
  local chainedShortMatch="^-[a-z]+$"
  local longMatch="^-{2}[a-z][a-z]+$"
  local proMatch="[a-z]+\.pro$"

  for ARG in "$@"
  do
    local valid=false
    # check if its a short flag
    if [[ $ARG =~ $shortMatch ]]
      then
      # break up the options if needed
      local len=${#ARG}
      while [ $len -gt 1 ]
      do
        # check if it's a valid short flag
        local flag=${ARG:($len-1):1}
        for VALIDOPT in "${SHORT_FLAGS[@]}"
        do
          if [ "$flag" = "$VALIDOPT" ]
            then
            valid=true
            OPTS+=("$VALIDOPT")
            break
          fi
        done
        let "len -= 1"
      done
      # if invalid input
      if ! $valid
        then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check of its a long flag
    elif [[ $ARG =~ $longMatch ]]
      then
      # check if it's a valid long flag
      local flag=${ARG:2}
      for VALIDOPT in "${LONG_FLAGS[@]}"
      do
        if [ "$flag" = "$VALIDOPT" ]
          then
          valid=true
          OPTS+=("$VALIDOPT")
          break
        fi
      done
      if ! $valid
        then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check if its a project file
    elif [[ $ARG =~ $proMatch ]]
      then
      # check if file exists
      if [ -e $ARG ]
        then
        PRJ+=("$ARG")
        valid=true
      else
        echo "ERROR: $ARG does not exist"
      fi

    # else input is invalid
    else
      echo "ERROR: $ARG is not valid input"
    fi

    if ! $valid
      then
      inv=true
    fi
  done

  # if there were errors
  if $inv
    then
    help
  fi
}

# check for conflicting options and set script flags
function checkopts () {
  # set the flags
  for OP in ${OPTS[@]}
  do
    if [ "${OP:0:1}" = "h" ]
      then
      help
    elif [ "${OP:0:1}" = "a" ]
      then
      APPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "p" ]
      then
      PREPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "c" ]
      then
      FOOTPRINTS=false
    elif [ "${OP:0:1}" = "f" ]
      then
      COMPONENTS=false
    fi
  done

  local inv=false
  # make sure there are no conflicting flags
  if $APPEND && $PREPEND
    then
    echo "ERROR: append and prepend options are mutually exclusive"
    inv=true
  fi
  if ! $FOOTPRINTS && ! $COMPONENTS
    then
    echo "ERROR: components-only and footprints-only options are mutually exclusive"
    inv=true
  fi
  # also make sure there are project files
  if [ ! "${PRJ[0]}" ]
    then
    echo "ERROR: no kicad project file entered"
    inv=true
  fi

  if $inv
    then
    help
  fi
}

function buildCompsList () {
  local dir=$(dirname "${BASH_SOURCE[0]}")"/components/*.lib"
  for C in $dir
  do
    local f=`basename $C`
    COMPS+=(${f%%.lib})
    #echo "hey look: $f"
  done
  echo "component libraries: ${COMPS[@]}"
}

function buildFootsList () {
  local dir=$(dirname "${BASH_SOURCE[0]}")"/footprints/*.mod"
  for F in $dir
  do
    local f=`basename $F`
    FOOTS+=(${f%%.mod})
    #echo "hey look: $f"
  done
  echo "footprint libraries: ${FOOTS[@]}"
}

function fixCompLibDir () {
  # find the header to start the section
  local secStart=`sed -n "/^\[$COMP_DIR_HEADING_MATCH\]$/ =" $P`
  echo "comp lib dir section starts @ $secStart"
  local secEnd=`sed -n "$secStart,$ /$HEADER_FORMAT/ =" $P`
  echo "comp lib dir section ends @ $secEnd"
  # find the end of the section
  # search for the library line in that range
  # if append or prepend, append new dir to the end
  # if replace, straight up replace that shit
  # if no lib line found, add the line
}

# do the magic
function run {
  echo "running on ${#PRJ[*]} projects:"
  for P in "${PRJ[@]}"
  do
    echo "$P"
  done
  echo "with these options:"
  echo "replace libraries: $REPLACE"
  echo "append libraries: $APPEND"
  echo "prepend libraries: $PREPEND"
  echo "use components: $COMPONENTS"
  echo "use footprints: $FOOTPRINTS"

  # do this for every project
  for P in "${PRJ[@]}"
  do
    echo "taking care of $P"
    
    # let's start with the components
    if $COMPONENTS
      then
      # um, get component list
      buildCompsList

      # edit the library path
      fixCompLibDir

      # edit the libraries
        # find the beginning of the section
        # find the end of the section
        # in the resulting range:
          # if append or prepend, get your library numbers figured out
            # new libraries will need numbering, old ones could need to be fixed
          # if replace, my life is easier
          # change lines until either list runs out
            # if new list, delete the remaining lines in the old list
            # elif the old list, insert remaining lines from the new list
        # output fixed project

    fi
    # then the footprints
    if $FOOTPRINTS
      then
      buildFootsList
    fi

  done
}

# start the script
go $@
